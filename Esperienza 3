

                    "ESPERIENZA 3"



In pratica dobbiamo creare una rete , nella quale eseguire delle policy di QoS

********************************************************************
Ps: Il termine QoS è spesso usato come sinonimo di Traffic Controll
********************************************************************

Una della features piu' importanti del kernel linux è la possibilità di controllare e modellare il traffico di rete

Traffic controll (tc) è il nome che viene dato a un sistema di code e di meccanismi , in grado di gestire
il traffico di rete che passa per un router. tc (traffic control) è un comando linux ( facente parte di iproute2) 
in grado di configurare lo scheduler di rete del kernel linux 

 Il controllo del traffico si basa su una singola coda FIFO che colleziona i pacchetti , determinando quali di questi 
 debba essere gestito ,e quali no.
 
 ______________________________________________
 Supponendo di trovarci nel GATEWAY (ROUTER)
 ______________________________________________
 
 Come sempre ,settiamo nel gw due interfacce di rete (Creiamo due sottoreti)
 Attiviamo il forwarding 
 echo "1" > /proc/sys/net/ipv4/ip_forward;
 oppure
 sysctl -w net.ipv4.ip_forward=1;

 Sappiamo che il TCP ha uno start piuttosto lento (handshaking); Dopo avere instaurato la comunicazione
 ,pero', diventa sempre piu' performante. E' possibile controllare quanto traffico è ricevuto su una rete LAN
 facendo droppare i pacchetti che passano per il gw , prima ancora che questi vengano forwardati.
 
 Ogni network device ha un root dove puo' essere settato un qdisc.

**********************************************************************************************************
qdisc è uno scheduler. Gli schedulers possono essere di tipo FIFO o piu' complessi. Possono , per esempio,
contenere classi e altre qdiscs
**********************************************************************************************************
Di default , il root ha una fifo_fast_qdisc

fifo_fast è il qdisc di default .Nei device di rete che non hanno subito modifiche, fifo_fast è settato sul root
il primo pacchetto che entra , è il primo pacchetto che esce.Detto in altre parole: NON CI SONO FAVORITISMI TRA I
PACCHETTI.

Basandoci su queste informazioni , la prima cosa da svolgere è di cancellare i qdisc presenti in root
CANCELLIAMO TUTTE LE qdiscs PRESENTI NEL DEVIDE eth0:


tc qdisc del dev eth0 root;


Le code di qdisc possono essere di due tipologie: Classfull e Classless

° Classless : Sono code che possono svolgere operazioni basilari su di un flusso di dati.Come: ordinare,rallentare o 
droppare pacchetti.

° Classfull : Sono code dotate di "classi". Quindi , se abbiamo la necessità di trattare in modo differente il traffico
generato da una rete , rispetto a quello generato da una altra , allora dobbiamo usare le qdisc Classfull!
(nostro caso)


tc qdisc add dev eth0 root handle 1: htb default 24;

Questa linea di codice setta una Hierarchical Token Bucket (HTB)
L'HTB è molto utile quando abbiamo intenzione di dividere la nostra banda.
Possiamo dividere la banda e dare ad ogni segmento cosi creato , una porzione di banda.
Il codice di sopra , quindi, genera una HTB nel root di eth0 e specfica che la classe 1:24
cioè , la classe 24 figlia di root (classe 1) è usata di default

tc class add dev eth0 parent 1: classid 1:1 htb rate 2mbps ceil 3mbps burst 1mb;

Crea una classe chiamata 1:1 ,diretto discendente di 1 (ovvero di root).
Anche questa classe usa un HTB per suddividere la sua banda. Setta il max rate a 2mbits, con un burst di 1 mb

(burst: quantitativo di banda in eccesso che può essere utilizzato per un periodo limitato di tempo.)




 
